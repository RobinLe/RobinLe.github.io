<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>robin Lee</title>
 <link href="https://robinle.github.io/atom.xml" rel="self"/>
 <link href="https://robinle.github.io/"/>
 <updated>2017-03-26T22:50:29+08:00</updated>
 <id>https://robinle.github.io</id>
 <author>
   <name>robin Lee</name>
   <email></email>
 </author>

 
 <entry>
   <title>Kubernetes认证与授权（一）</title>
   <link href="https://robinle.github.io/k8s/2017/03/25/Kubernetes%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83-%E4%B8%80/"/>
   <updated>2017-03-25T00:00:00+08:00</updated>
   <id>https://robinle.github.io/k8s/2017/03/25/Kubernetes认证与授权（一）</id>
   <content type="html">&lt;p&gt;普通用户和Service accounts&lt;/p&gt;

&lt;p&gt;client certificates&lt;/p&gt;

&lt;p&gt;bearer tokens&lt;/p&gt;

&lt;p&gt;an authenticating proxy&lt;/p&gt;

&lt;p&gt;HTTP basic auth&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Docker存储驱动DeviceMapper</title>
   <link href="https://robinle.github.io/docker/2017/03/13/Docker%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8%E4%B9%8BDeviceMapper/"/>
   <updated>2017-03-13T00:00:00+08:00</updated>
   <id>https://robinle.github.io/docker/2017/03/13/Docker存储驱动之DeviceMapper</id>
   <content type="html">&lt;p&gt;上篇介绍了Docker存储驱动aufs以及AUFS文件系统，本篇聊聊&lt;code class=&quot;highlighter-rouge&quot;&gt;devicemapper&lt;/code&gt;存储驱动以及&lt;strong&gt;Device Mapper&lt;/strong&gt;技术，&lt;strong&gt;Device Mapper&lt;/strong&gt;较之&lt;strong&gt;AUFS&lt;/strong&gt;工作相对底层。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;device-mapper是一种linux块设备映射技术框架&quot;&gt;Device Mapper是一种Linux块设备映射技术框架&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;Device Mapper&lt;/strong&gt;不同于&lt;strong&gt;AUFS&lt;/strong&gt;、&lt;strong&gt;ext4&lt;/strong&gt;、&lt;strong&gt;NFS&lt;/strong&gt;等，因为它并不是一个文件系统（File System），而是Linux内核映射块设备的一种技术框架。提供的一种从逻辑设备（虚拟设备）到物理设备的映射框架机制，在该机制下，用户可以很方便的根据自己的需要制定实现存储资源的管理策略。&lt;/p&gt;

&lt;p&gt;当前比较流行的 Linux 下的逻辑卷管理器如 LVM2（Linux Volume Manager 2 version)、EVMS(Enterprise Volume Management System)、dmraid(Device Mapper Raid Tool)等都是基于该机制实现的。&lt;/p&gt;

&lt;p&gt;值得一提的是&lt;strong&gt;Device Mapper&lt;/strong&gt;工作在块级别（block），并不工作在文件级别（file）。&lt;strong&gt;Device Mapper&lt;/strong&gt;自Linux 2.6.9后编入Linux内核，所有基于Linux内核2.6.9以后的发行版都内置&lt;strong&gt;Device Mapper&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;起初Docker仅在Ubuntu和Debian上使用AUFS运行，在Docker火起来后，另一个Linux大户Redhat家族也想使用Docker，但是由于AUFS并未编入Linux内核，也并未写入Redhat家族内核，所以包括RedHat和CentOS均无法使用Docker。RedHat开发人员曾想把AUFS写入内核以支持Docker，但最终还是选用的Device mapper作为后台存储技术，而Docker方面重新设计了Docker引擎以支持多种驱动，并开发devicemapper存储驱动支持Device Mapper作为后台存储。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;device-mapper主要分为用户空间部分和内核空间部分&quot;&gt;Device Mapper主要分为用户空间部分和内核空间部分&lt;/h5&gt;
&lt;p&gt;用户空间相关部分主要负责配置具体的策略和控制逻辑，比如逻辑设备和哪些物理设备建立映射，怎么建立这些映射关系等，包含&lt;code class=&quot;highlighter-rouge&quot;&gt;device mapper&lt;/code&gt;库和&lt;code class=&quot;highlighter-rouge&quot;&gt;dmsetup&lt;/code&gt;工具。对用户空间创建删除&lt;code class=&quot;highlighter-rouge&quot;&gt;device mapper&lt;/code&gt;设备的操作进行封装。&lt;/p&gt;

&lt;p&gt;内核中主要提供完成这些用户空间策略所需要的机制，负责具体过滤和重定向 IO 请求。通过不同的驱动插件，转发IO请求至目的设备上。附上&lt;strong&gt;Device Mapper&lt;/strong&gt;架构图。
&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/2017031310.gif&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;device-mapper技术分析&quot;&gt;Device Mapper技术分析&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Device Mapper&lt;/strong&gt;作为Linux块设备映射技术框架，向外部提供逻辑设备。包含三个重要概念，映射设备（mapped device），映射表（map table），目标设备（target device）。&lt;/p&gt;

&lt;p&gt;映射设备即对外提供的逻辑设备，映射设备向下寻找必须找到支撑的目标设备，映射表存储映射设备和目标设备的映射关系。目标设备可以是映射设备或者物理设备，如果目标设备是一块映射设备，则属于嵌套，理论上可以无限迭代下去。&lt;/p&gt;

&lt;p&gt;简而言之，&lt;strong&gt;Device Mapper&lt;/strong&gt;对外提供一个虚拟设备供使用，而这块虚拟设备可以通过映射表找到相应的地址，该地址可以指向一块物理设备，也可以指向一个虚拟设备。
&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/2017031311.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;映射表，是由用户空间创建，传递到内核空间。映射驱动在内核空间是插件，已实现的映射驱动（target driver） 插件包括软 raid、软加密、逻辑卷条带、多路径（mulitpath）、镜像（mirror）、快照（snapshot）等。&lt;/p&gt;

&lt;p&gt;Device Mapper中的IO流处理，从虚拟设备（逻辑设备）根据映射表并指定特定的映射驱动转发到目标设备上。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;docker中的device-mapper核心技术&quot;&gt;Docker中的Device Mapper核心技术&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Docker&lt;/strong&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;devicemapper&lt;/code&gt;驱动有三个核心概念，&lt;code class=&quot;highlighter-rouge&quot;&gt;copy on-write（写复制）&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;thin-provisioning（瘦供给）&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;snapshot（快照）&lt;/code&gt;，首先简单介绍一下这三种技术。&lt;/p&gt;

&lt;p&gt;CoW（copy on write）写复制，一些文件系统提供的写时复制策略，&lt;strong&gt;AUFS&lt;/strong&gt;文中已介绍，不赘述。&lt;code class=&quot;highlighter-rouge&quot;&gt;devicemapper&lt;/code&gt;支持在块级别（block）写复制。&lt;/p&gt;

&lt;p&gt;Snapshot（快照技术），&lt;strong&gt;SNIA定义&lt;/strong&gt;：关于指定数据集合的一个完全可用拷贝，该拷贝包括相应数据在某个时间点（拷贝开始的时间点）的映像。快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。而从具体的技术细节来讲，快照是指向保存在存储设备中的数据的引用标记或指针。&lt;/p&gt;

&lt;p&gt;接下来的档案修改或任何新增、删除动作，均不会覆写原本数据所在的磁盘区块，而是将修改部分写入其它可用的磁盘区块中。device mapper映射驱动支持snapshot技术。&lt;/p&gt;

&lt;p&gt;Thin-provisioning（瘦供给），直译为精简配置，《容器与容器云》（浙大SEL实验室著）同译为精简配置，但个人认为瘦供给更易理解，瘦供给是动态分配，需要多少分配多少，区别于传统分配固定空间从而造成的资源浪费，附下图
&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/2017031312.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;docker中devicemapper驱动存储&quot;&gt;Docker中devicemapper驱动存储&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;首先创建一个瘦资源池（thin pool，使用瘦供给技术，存储动态分配），瘦资源池使用2块设备，一个用于存储数据，一个用于存储元数据（虚拟设备和目标设备的映射表）&lt;/li&gt;
  &lt;li&gt;基于该瘦资源池创建基础设备（Device Mapper中的逻辑设备）&lt;/li&gt;
  &lt;li&gt;所有的镜像数据均基于该基础设备创建快照，容器层则基于镜像层创建快照。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/2017031313.png&quot; alt=&quot;img&quot; /&gt;
&lt;em&gt;Tips：Docker在创建瘦资源池（thin pool）的时候，默认使用loop-lvm模式，该模式使用稀疏文件构建资源池。另一种模式是direct-lvm模式，该模式使用块设备创建资源池。docker模式采用loop-lvm是因为不需要额外配置，而在生产环境中建议使用direct-lvm模式，该模式需要手动配置数据设备从而构建瘦资源池。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h5 id=&quot;使用devicemapper的读写操作&quot;&gt;使用devicemapper的读写操作&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;devicemapper&lt;/code&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;snapshot&lt;/code&gt;快照技术，每层镜像都是基于上一个镜像的快照构建。所有读取数据操作，如果数据在低层快照中，则会重定向到低层快照数据地址并取出数据。写数据会向瘦资源池（thin pool）请求空间写数据，由于&lt;code class=&quot;highlighter-rouge&quot;&gt;devicemapper&lt;/code&gt;工作在block层，空间分配以块为单位，docker中默认块大小为64KB。&lt;/p&gt;

&lt;p&gt;镜像的复用即通过&lt;code class=&quot;highlighter-rouge&quot;&gt;snapshot&lt;/code&gt;快照技术实现，有别于aufs等存储驱动。所有的新增和删除都是不覆盖原本数据块，而是使用其他可用的新的数据块进行操作。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;存储空间节省：&lt;/strong&gt;由于工作在block级，每一个block 64KB，尤其是在更新大文件的时候，不需要复制整个文件，只需要更新文件有修改所在的block，有效节省存储空间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;存取速度：&lt;/strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;devicemapper&lt;/code&gt;逻辑设备映射目标设备，目标设备构建于SSD等高速存储上，能获得更好的速度。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;兼容性好：&lt;/strong&gt;由于&lt;strong&gt;Device Mapper&lt;/strong&gt;从Linux 2.6以后就写入内核，所以尽管发行版不同，但都能使用&lt;code class=&quot;highlighter-rouge&quot;&gt;devicemapper&lt;/code&gt;驱动。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内存资源浪费：&lt;/strong&gt;启动N个相同的容器会加载N份相同文件到内存，势必造成主机资源浪费，不建议在PaaS或者资源密集场合使用。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Tips：关于资源浪费，因为devicemapper工作在block，很难实现pagecache&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;参考资料&quot;&gt;参考资料&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.docker.com/engine/userguide/storagedriver/device-mapper-driver/#device-mapper-and-docker-performance&quot;&gt;https://docs.docker.com/engine/userguide/storagedriver/device-mapper-driver/#device-mapper-and-docker-performance&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-devmapper/&quot;&gt;https://www.ibm.com/developerworks/cn/linux/l-devmapper/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://coolshell.cn/articles/17200.html&quot;&gt;http://coolshell.cn/articles/17200.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.kernel.org/doc/Documentation/device-mapper/&quot;&gt;https://www.kernel.org/doc/Documentation/device-mapper/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://hustcat.github.io/overlayfs-intro/&quot;&gt;http://hustcat.github.io/overlayfs-intro/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Device_mapper&quot;&gt;https://en.wikipedia.org/wiki/Device_mapper&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Docker存储驱动AUFS</title>
   <link href="https://robinle.github.io/docker/2017/03/13/Docker%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8%E4%B9%8BAUFS/"/>
   <updated>2017-03-13T00:00:00+08:00</updated>
   <id>https://robinle.github.io/docker/2017/03/13/Docker存储驱动之AUFS</id>
   <content type="html">&lt;p&gt;Docker存储驱动之AUFS，关于Docker的Image（镜像）与Container（容器）的存储以及存储驱动之AUFS&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;docker存储驱动简介&quot;&gt;Docker存储驱动简介&lt;/h4&gt;
&lt;p&gt;Docker内置多种存储驱动，每种存储驱动都是基于Linux文件系统（Linux FS）或者卷管理（Volume Manager）技术。一般来说，Docker存储驱动的名称与文件系统（存储技术）同名，见下表对应关系&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;文件系统/存储&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;存储驱动名称&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;OverlayFS&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;overlay/overlay2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;AUFS&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;aufs&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Btrfs&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;btrfs&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Device Mapper&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;devicemapper&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;VFS&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;vfs&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ZFS&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;zfs&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;aufs简介&quot;&gt;AUFS简介&lt;/h4&gt;
&lt;p&gt;AUFS，起初名为&lt;code class=&quot;highlighter-rouge&quot;&gt;AnotherUnionFileSystem&lt;/code&gt;，是一种UnionFS，V2版本后更名为&lt;code class=&quot;highlighter-rouge&quot;&gt;advanced multi-layered unification fileystem&lt;/code&gt;即高级多层统一文件系统。&lt;/p&gt;

&lt;p&gt;AUFS是一位名为岡岛纯二郎的日本人于2006年基于UnionFS开发的，目的也是为了提高其可靠性和性能，也在AUFS上实现了一些新的概念比如写分支平衡等（writeable branch balancing）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;纯二郎先生曾多次提交aufs到linux主干，但一直被拒绝，可纯二郎依旧日以继夜的修改代码，并不断提交，可一直没有被merge，而纯二郎最终也放弃提交代码到linux主干，从而aufs也一直没有进入linux内核。关于为何linux不要aufs，主要是aufs代码太糟糕，“dense，unreadable，and uncommented”，乱，可读性差，没注释…。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Tips：虽然AUFS没有进入Liunx内核，但是AUFS默认是写入Ubuntu内核的，Docker早期仅支持Ubuntu便是这个原因&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;aufs核心概念&quot;&gt;AUFS核心概念&lt;/h4&gt;
&lt;p&gt;将多个目录合并成一个虚拟文件系统，成员目录称为虚拟文件系统的一个分支（&lt;strong&gt;branch&lt;/strong&gt;）。&lt;/p&gt;

&lt;p&gt;例如，把&lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/var&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/opt&lt;/code&gt;三个目录联合挂着到&lt;code class=&quot;highlighter-rouge&quot;&gt;/aufs&lt;/code&gt;目录下，则&lt;code class=&quot;highlighter-rouge&quot;&gt;/aufs&lt;/code&gt;目录可见&lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/var&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/opt&lt;/code&gt;目录下的所有文件。而每个成员目录，则称为虚拟文件系统的一个&lt;strong&gt;branch&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/2017031301.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个branch可以指定&lt;code class=&quot;highlighter-rouge&quot;&gt;readwrite/whiteout-able/readonly&lt;/code&gt;权限，&lt;strong&gt;只读（ro），读写（rw），写隐藏（wo）&lt;/strong&gt;。一般情况下，aufs只有最上层的branch具有读写权限，其余branch均为只读权限。只读branch只能逻辑上修改。&lt;/p&gt;

&lt;p&gt;例如，把&lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp&lt;/code&gt;目录和&lt;code class=&quot;highlighter-rouge&quot;&gt;/var&lt;/code&gt;目录联合挂载到&lt;code class=&quot;highlighter-rouge&quot;&gt;/aufs&lt;/code&gt;目录下，&lt;code class=&quot;highlighter-rouge&quot;&gt;/var&lt;/code&gt;目录挂载为顶层branch具有&lt;strong&gt;rw&lt;/strong&gt;权限，而&lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp&lt;/code&gt;目录挂载为下层branch，具有&lt;strong&gt;ro&lt;/strong&gt;权限。如果把&lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp&lt;/code&gt;目录&lt;code class=&quot;highlighter-rouge&quot;&gt;/var&lt;/code&gt;目录&lt;code class=&quot;highlighter-rouge&quot;&gt;/opt&lt;/code&gt;目录联合挂载到&lt;code class=&quot;highlighter-rouge&quot;&gt;/aufs&lt;/code&gt;目录下，只有最顶层&lt;code class=&quot;highlighter-rouge&quot;&gt;/opt&lt;/code&gt; branch具有&lt;strong&gt;rw&lt;/strong&gt;权限，下层branch均为&lt;strong&gt;ro&lt;/strong&gt;权限&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/2017031306.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Tips：mount -t aufs -o br=/tmp:/var:/opt none /aufs&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;该指令联合挂载&lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/var&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;/opt&lt;/code&gt;至挂载点&lt;code class=&quot;highlighter-rouge&quot;&gt;/aufs&lt;/code&gt;，按照从左到右的顺序&lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp&lt;/code&gt;位于顶层branch，而&lt;code class=&quot;highlighter-rouge&quot;&gt;/opt&lt;/code&gt;位于最底层branch，所有的branch按照顺序共同构成&lt;code class=&quot;highlighter-rouge&quot;&gt;/aufs&lt;/code&gt;栈&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;AUFS每层branch可以动态的增加删除，每增加一层，下层默认置为&lt;strong&gt;ro&lt;/strong&gt;，最上一层为&lt;strong&gt;rw&lt;/strong&gt;。删除branch是在aufs挂载点移除，并未删除挂载目录。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;docker中的aufs&quot;&gt;Docker中的AUFS&lt;/h4&gt;
&lt;p&gt;AUFS是Docker使用的第一个存储驱动，长时间以来，一直很稳定。虽然目前Docker支持多种存储驱动，而在Ubuntu中默认使用aufs存储驱动，可以使用docker info指令进行查看。对于Docker而言，AUFS有很多优秀的特点，比如&lt;strong&gt;快速启动容器&lt;/strong&gt;，&lt;strong&gt;高效存储利用率&lt;/strong&gt;，&lt;strong&gt;高效内存利用率&lt;/strong&gt;等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Docker镜像和AUFS branch对应关系&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Docker镜像（image）是由一个或多个AUFS branch组成，并且所有的branch均为只读权限。简单来说，AUFS所有&lt;strong&gt;ro&lt;/strong&gt; branch按照一定顺序堆积构成docker image镜像。&lt;/p&gt;

&lt;p&gt;在运行容器的时候，创建一个AUFS branch位于image层之上，具有&lt;strong&gt;rw&lt;/strong&gt;权限，并把这些branch联合挂载到一个挂载点下。这就是Docker能够一个镜像运行多个容器的原理所在。&lt;/p&gt;

&lt;p&gt;例如，image有3个目录位于&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/docker/aufs/diff/&lt;/code&gt;文件夹内，当基于该image创建容器时，创建一个容器运行目录，同样位于&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/docker/aufs/diff/&lt;/code&gt;目录下，并使用aufs联合挂载image目录和container目录到&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/docker/aufs/mnt/&lt;/code&gt;目录下。&lt;/p&gt;

&lt;p&gt;每一个目录在aufs内都是一层branch，只有顶层容器branch可读写，下层image branch均只读。创建多个容器时，只需创建多个容器运行目录，使用aufs把容器运行目录挂载在image目录之上，即实现一个image运行多个container。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/2017031307.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图中基于同一个image运行两个容器，低层image一致，每启动一个新容器，便会新建一个目录作为aufs branch并与image branch进行联合挂载。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;容器文件读写与删除&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当容器需要修改一个文件，而该文件位于低层branch时，顶层branch会直接复制低层branch的文件至顶层再进行修改，而低层的文件不变，这种方式即是&lt;strong&gt;CoW&lt;/strong&gt;技术（写复制），AUFS默认支持&lt;strong&gt;Cow&lt;/strong&gt;技术。&lt;/p&gt;

&lt;p&gt;当容器删除一个低层branch文件时，只是在顶层branch对该文件进行重命名并隐藏，实际并未删除文件，只是不可见，这种方式即AUFS的&lt;strong&gt;whiteout&lt;/strong&gt;（写隐藏）。&lt;/p&gt;

&lt;p&gt;下图所示，容器层所见&lt;strong&gt;file1&lt;/strong&gt;文件为镜像层文件，当需要修改&lt;strong&gt;file1&lt;/strong&gt;时，会从镜像层把文件复制到容器层，然后进行修改，从而保证镜像层数据的完整性和复用性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/2017031308.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下图所示，当需要删除&lt;strong&gt;file1&lt;/strong&gt;时，由于&lt;strong&gt;file1&lt;/strong&gt;是镜像层文件，容器层会创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;.wh&lt;/code&gt;前置的隐藏文件，从而实现对&lt;strong&gt;file1&lt;/strong&gt;的隐藏，实际并未删除&lt;strong&gt;file1&lt;/strong&gt;，从而保证镜像层数据的完整性和复用性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/2017031309.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Docker本地存储目录&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Docker镜像存在在&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/docker/aufs/diff/&lt;/code&gt;目录下。&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/docker/aufs/layers/&lt;/code&gt;目录存储image的元信息，主要是image的每一层layer组织顺序（AUFS branch堆积顺序）。&lt;/p&gt;

&lt;p&gt;Docker容器挂载点位于&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/docker/aufs/mnt/&amp;lt;container-id&amp;gt;&lt;/code&gt;目录下，该目录即为AUFS联合挂载点。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Tips：早期镜像的每一层数据存储在&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/docker/aufs/diff/&lt;/code&gt;目录下，镜像ID与目录名同名，从docker v1.10版本之后镜像ID不再与&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/docker/aufs/diff/&lt;/code&gt;目录下的目录同名，而是采用一个安全的hash值作为镜像存储文件夹名称。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;采用 aufs作为 docker 的容器存储驱动，使用AUFS技术，能够提供如下好处&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;节省存储空间&lt;/strong&gt;：多个容器可以共享 基础镜像（base image）存储&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;快速部署：&lt;/strong&gt;如果要部署多个容器，基础镜像（base image）可以避免多次拷贝&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内存更省：&lt;/strong&gt;因为多个容器共享base image，以及OS的disk缓存机制，多个容器中的进程命中缓存内容的几率大大增加&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;允许在不更改基础镜像的同时修改其目录中的文件：&lt;/strong&gt;所有写操作都发生在最上层的writeable层中，这样可以大大增加base image能共享的文件内容。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;参考文献&quot;&gt;参考文献&lt;/h4&gt;
&lt;p&gt;1. &lt;a href=&quot;https://docs.docker.com/engine/userguide/storagedriver/aufs-driver/#related-information&quot;&gt;https://docs.docker.com/engine/userguide/storagedriver/aufs-driver/#related-information&lt;/a&gt;&lt;br /&gt;
2. http://aufs.sourceforge.net/&lt;br /&gt;
3. &lt;a href=&quot;https://en.wikipedia.org/wiki/Aufs&quot;&gt;https://en.wikipedia.org/wiki/Aufs &lt;/a&gt;&lt;br /&gt;
4. 于烨，李斌，刘思尧Docker 技术的移植性分析研究。软件，2015,（7）&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>容器部署kubernetes</title>
   <link href="https://robinle.github.io/k8s/2017/01/14/%E5%AE%B9%E5%99%A8%E9%83%A8%E7%BD%B2kubernetes/"/>
   <updated>2017-01-14T00:00:00+08:00</updated>
   <id>https://robinle.github.io/k8s/2017/01/14/容器部署kubernetes</id>
   <content type="html">&lt;p&gt;本文介绍在使用容器方式部署kubernetes，在centos7主机上，基于docker v1.12.5部署kubernetes v1.5.0。仅部署kubernetes必要组件，各个组件均封装成容器部署运行。&lt;/p&gt;

&lt;h3 id=&quot;测试环境&quot;&gt;测试环境&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;HOST&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;OS&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Dependence&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Role&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;192.168.3.100&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;CentOS7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Docker v1.12.5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;master&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;192.168.3.101&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;CentOS7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Docker v1.12.5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;node&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;kubernetes必要组件&quot;&gt;Kubernetes必要组件&lt;/h3&gt;

&lt;h4 id=&quot;master&quot;&gt;master&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Component&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Version&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Format&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;etcd&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;v0.3.15&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;container&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kube-apiserver&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;v1.5.0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;container&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kube-controller-manager&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;v1.5.0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;container&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kube-schduler&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;v1.5.0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;container&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;node&quot;&gt;node&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Component&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Version&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Format&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kubelet&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;v1.5.0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;binary&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kube-proxy&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;v1.5.0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;container&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;etcd容器获取及启动&quot;&gt;etcd容器获取及启动&lt;/h4&gt;

&lt;p&gt;获取官方官方镜像&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@k8s-master ~]# docker pull quay.io/coreos/etcd:v3.0.15
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从&lt;strong&gt;Docerfile&lt;/strong&gt;构建&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# description:     etcd v0.3.15-linux-amd64&lt;/span&gt;
FROM alpine:3.4

ADD etcd /usr/local/bin/
ADD etcdctl /usr/local/bin/
RUN mkdir -p /var/etcd/
RUN mkdir -p /var/lib/etcd/

EXPOSE 2379 2380

&lt;span class=&quot;c&quot;&gt;# Define default command.&lt;/span&gt;
CMD &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/usr/local/bin/etcd&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;启动&lt;strong&gt;etcd&lt;/strong&gt;容器，监听2379，2380，4001端口&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@k8s-master ~]# docker run -p 4001:4001 -p 2380:2380 -p 2379:2379 --name k8s-etcd k8s/etcd:v3.0.15 etcd\
 -name etcd0 \
 -advertise-client-urls http://192.168.3.100:2379,http://192.168.3.100:4001 \
 -listen-client-urls http://0.0.0.0:2379,http://0.0.0.0:4001 \
 -initial-advertise-peer-urls http://192.168.3.100:2380 \
 -listen-peer-urls http://0.0.0.0:2380 \
 -initial-cluster-token etcd-cluster-1 \
 -initial-cluster etcd0=http://192.168.3.100:2380 \
 -initial-cluster-state new
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/28.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;k8s组件容器获取及启动&quot;&gt;k8s组件容器获取及启动&lt;/h4&gt;

&lt;p&gt;下载官方编译后的二进制文件包(https://storage.googleapis.com/kubernetes-release/release/v1.5.0/kubernetes-server-linux-amd64.tar.gz)，解压后在&lt;code class=&quot;highlighter-rouge&quot;&gt;kubernetes/server/bin&lt;/code&gt;目录下拥有各个组件二进制文件和镜像包&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@k8s-master bin]# pwd
/root/kubernetes/server/bin
[root@k8s-master bin]# ll -h
total 1.3G
-rwxr-x---. 1 root root 145M Dec 13 07:45 hyperkube
-rwxr-x---. 1 root root  91M Dec 13 07:45 kubeadm
-rwxr-x---. 1 root root 118M Dec 13 07:45 kube-apiserver
-rw-r-----. 1 root root   33 Dec 13 07:45 kube-apiserver.docker_tag
-rw-r-----. 1 root root 119M Dec 13 07:45 kube-apiserver.tar
-rwxr-x---. 1 root root  97M Dec 13 07:45 kube-controller-manager
-rw-r-----. 1 root root   33 Dec 13 07:45 kube-controller-manager.docker_tag
-rw-r-----. 1 root root  98M Dec 13 07:45 kube-controller-manager.tar
-rwxr-x---. 1 root root  49M Dec 13 07:46 kubectl
-rwxr-x---. 1 root root 6.6M Dec 13 07:45 kube-discovery
-rwxr-x---. 1 root root  44M Dec 13 07:45 kube-dns
-rwxr-x---. 1 root root  46M Dec 13 07:46 kubefed
-rwxr-x---. 1 root root 103M Dec 13 07:45 kubelet
-rwxr-x---. 1 root root  44M Dec 13 07:45 kube-proxy
-rw-r-----. 1 root root   33 Dec 13 07:46 kube-proxy.docker_tag
-rw-r-----. 1 root root 174M Dec 13 07:46 kube-proxy.tar
-rwxr-x---. 1 root root  51M Dec 13 07:45 kube-scheduler
-rw-r-----. 1 root root   33 Dec 13 07:46 kube-scheduler.docker_tag
-rw-r-----. 1 root root  52M Dec 13 07:46 kube-scheduler.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/27.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;直接&lt;code class=&quot;highlighter-rouge&quot;&gt;docker load&lt;/code&gt;镜像&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@k8s-master bin]# docker load -i kube-apiserver.tar
[root@k8s-master bin]# docker load -i kube-controller-manager.tar
[root@k8s-master bin]# docker load -i kube-scheduler.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者使用&lt;strong&gt;Dockerfile&lt;/strong&gt;构建镜像&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# description:      kube-apiserver, kubernetes-1.5.0
FROM busybox:1.25
ADD kube-apiserver /usr/local/bin/

---
# description:      kube-controller-manager, kubernetes-1.5.0
FROM busybox:1.25
ADD kube-controller-manager /usr/local/bin/

---
# description:      kube-scheduler, kubernetes-1.5.0
FROM busybox:1.25
ADD kube-scheduler /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/30.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;kube-apiserver启动&quot;&gt;kube-apiserver启动&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@k8s-master ~]# docker run -p 8080:8080 --name k8s-apiserver k8s/kube-apiserver:v1.5.0 kube-apiserver \
 --insecure-bind-address=0.0.0.0 \
 --insecure-port=8080 \
 --etcd-servers=http://172.17.0.2:2379 \
 --logtostderr=true \
 --service-cluster-ip-range=10.10.3.0/24 \
 --advertise-address=192.168.3.100
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/29.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;kube-controller-manager启动&quot;&gt;kube-controller-manager启动&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@k8s-master ~]# docker run --name k8s-controller k8s/kube-controller-manager:v1.5.0 kube-controller-manager \
 --logtostderr=true \
 --master=172.17.0.3:8080
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/31.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;kube-schduler启动&quot;&gt;kube-schduler启动&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@k8s-master ~]# docker run --name k8s-scheduler k8s/kube-scheduler:v1.5.0 kube-scheduler \
 --logtostderr=true \
 --master=172.17.0.3:8080
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/32.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>ELK容器化部署</title>
   <link href="https://robinle.github.io/docker/2017/01/06/ELK%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
   <updated>2017-01-06T00:00:00+08:00</updated>
   <id>https://robinle.github.io/docker/2017/01/06/ELK容器化部署</id>
   <content type="html">&lt;h3 id=&quot;测试环境&quot;&gt;测试环境&lt;/h3&gt;

&lt;p&gt;在一台安装有&lt;strong&gt;docker v1.12.5&lt;/strong&gt;版本的主机上，测试ELK容器化运行，所需镜像及版本如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Host&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;OS&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Dependence&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Images&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;192.168.3.48&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Ubuntu16.04&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Docker v1.12.5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;logstash:5.1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;192.168.3.48&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Ubuntu16.04&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Docker v1.12.5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;elasticsearch:5.1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;192.168.3.48&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Ubuntu16.04&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Docker v1.12.5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;kibana:5.1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;启动elasticsearch容器&quot;&gt;启动elasticsearch容器&lt;/h3&gt;

&lt;p&gt;下载&lt;strong&gt;elasticsearch&lt;/strong&gt;镜像&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@192.168.3.48:~# docker pull elasticsearch:5.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;启动&lt;strong&gt;elasticsearch&lt;/strong&gt;容器，并开放&lt;strong&gt;9200&lt;/strong&gt;端口&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@192.168.3.48:~# docker run -it --rm -p 9200:9200 --name elasticsearch elasticsearch
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/24.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;启动logstash容器&quot;&gt;启动logstash容器&lt;/h3&gt;

&lt;p&gt;创建&lt;strong&gt;logstash&lt;/strong&gt;配置文件，读取&lt;code class=&quot;highlighter-rouge&quot;&gt;/opt/logs&lt;/code&gt;目录下的&lt;strong&gt;testlog&lt;/strong&gt;文件，输出到&lt;strong&gt;elasticsearch&lt;/strong&gt;和标准输出&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@192.168.3.48:~# mkdir -p /opt/configdir
root@192.168.3.48:~# vi /opt/configdir/logstash.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;input {
  file {
    path =&amp;gt; &quot;/opt/logs/testlog&quot;
    start_position =&amp;gt; &quot;beginning&quot;
  }
#stdin {}
}

filter { }

output {
  elasticsearch {
    hosts =&amp;gt; [&quot;192.168.3.48:9200&quot;]
  }
  stdout { codec =&amp;gt; rubydebug }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建测试日志文件（示例为syslog格式的web日志），修改文件权限使&lt;strong&gt;logstash&lt;/strong&gt;可读&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@192.168.3.48:~# mkdir -p /opt/logs
root@192.168.3.48:~# touch /opt/logs/testlog
root@192.168.3.48:~# chmod 755 /opt/logs/testlog
root@192.168.3.48:~# vi /opt/logs/testlog
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;199.72.81.55 - - [01/Jul/1995:00:00:01 -0400] &quot;GET /history/apollo/ HTTP/1.0&quot; 200 6245
unicomp6.unicomp.net - - [01/Jul/1995:00:00:06 -0400] &quot;GET /shuttle/countdown/ HTTP/1.0&quot; 200 3985
199.120.110.21 - - [01/Jul/1995:00:00:09 -0400] &quot;GET /shuttle/missions/sts-73/mission-sts-73.html HTTP/1.0&quot; 200 4085
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;启动容器，挂载本地配置文件目录和日志文件目录。成功会自动读取日志文件并转发到标准输出和&lt;strong&gt;elasticsearch&lt;/strong&gt;中，如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@192.168.3.48:~# docker run -it --rm -v /opt/configdir/:/configdir logstash -f /configdir/logstash.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/25.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;启动kibana容器&quot;&gt;启动kibana容器&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;logstash&lt;/strong&gt;集中对日志进行收集过滤，&lt;strong&gt;elasticsearch&lt;/strong&gt;提供日志存储与索引，&lt;strong&gt;kibana&lt;/strong&gt;对elasticsearch中的数据进行可视化。&lt;/p&gt;

&lt;p&gt;启动&lt;strong&gt;kibana&lt;/strong&gt;容器，设置&lt;strong&gt;elasticsearch&lt;/strong&gt;地址，开放&lt;strong&gt;5601&lt;/strong&gt;端口&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@192.168.3.48:~# docker run -it --rm -p 5601:5601 --name kibana -e ELASTICSEARCH_URL=http://192.168.3.48:9200 kibana
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/26.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Docker日志解决方案（rsyslog+logstash）</title>
   <link href="https://robinle.github.io/docker/2017/01/05/Docker-rsyslog-logstash/"/>
   <updated>2017-01-05T00:00:00+08:00</updated>
   <id>https://robinle.github.io/docker/2017/01/05/Docker-rsyslog-logstash</id>
   <content type="html">&lt;h3 id=&quot;测试环境&quot;&gt;测试环境&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Host&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;OS&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;IP&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Services&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;syslog服务器&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Ubuntu16.04&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;192.168.3.48&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;rsyslog，logstash&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;docker服务器&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Ubuntu16.04&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;192.168.3.45&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;nginx&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;docker服务器启动nginx容器，nginx容器日志通过syslog传到syslog服务器，syslog服务器把日志输出到logstash中。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;syslog日志服务器配置&quot;&gt;Syslog日志服务器配置&lt;/h3&gt;

&lt;p&gt;修改&lt;strong&gt;rsyslog&lt;/strong&gt;配置文件&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/rsyslog.conf&lt;/code&gt;，取消&lt;strong&gt;TCP&lt;/strong&gt;或者&lt;strong&gt;UDP&lt;/strong&gt;日志接收模块注释，下图开启&lt;strong&gt;TCP514端口&lt;/strong&gt;接收日志&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@192.168.3.48:~# vi /etc/rsyslog.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/18.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;创建日志转发模板文件&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/rsyslog.d/01-template-json.conf&lt;/code&gt;，使用&lt;strong&gt;json&lt;/strong&gt;格式进行日志转发&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@192.168.3.48:~# touch /etc/rsyslog.d/01-template-json.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;输入以下文件内容吗，定义&lt;strong&gt;syslog&lt;/strong&gt;的&lt;strong&gt;json&lt;/strong&gt;模板及各个字段，&lt;a href=&quot;http://www.rsyslog.com/doc/v8-stable/configuration/properties.html&quot;&gt;更多字段内容&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;template(name=&quot;json-template&quot;
  type=&quot;list&quot;) {

    constant(value=&quot;{&quot;)
      constant(value=&quot;\&quot;@timestamp\&quot;:\&quot;&quot;)     property(name=&quot;timereported&quot; dateFormat=&quot;rfc3339&quot;)
      constant(value=&quot;\&quot;,\&quot;@version\&quot;:\&quot;1&quot;)
      constant(value=&quot;\&quot;,\&quot;message\&quot;:\&quot;&quot;)     property(name=&quot;msg&quot; format=&quot;json&quot;)
      constant(value=&quot;\&quot;,\&quot;sysloghost\&quot;:\&quot;&quot;)  property(name=&quot;hostname&quot;)
      constant(value=&quot;\&quot;,\&quot;severity\&quot;:\&quot;&quot;)    property(name=&quot;syslogseverity-text&quot;)
      constant(value=&quot;\&quot;,\&quot;facility\&quot;:\&quot;&quot;)    property(name=&quot;syslogfacility-text&quot;)
      constant(value=&quot;\&quot;,\&quot;programname\&quot;:\&quot;&quot;) property(name=&quot;programname&quot;)
      constant(value=&quot;\&quot;,\&quot;procid\&quot;:\&quot;&quot;)      property(name=&quot;procid&quot;)
    constant(value=&quot;\&quot;}\n&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建日志转发配置文件&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/rsyslog.d/60-output.conf&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@192.168.3.48:~# touch /etc/rsyslog.d/60-output.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;输入以下内容，定义所有日志使用&lt;code class=&quot;highlighter-rouge&quot;&gt;json-template&lt;/code&gt;模板转发到&lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.3.48:10514&lt;/code&gt;，&lt;strong&gt;2个@@表示TCP端口，1个@表示UDP端口&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# This line sends all lines to defined IP address at port 10514,
# using the &quot;json-template&quot; format template

*.*                         @@192.168.3.48:10514;json-template
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重启&lt;strong&gt;rsyslog&lt;/strong&gt;服务&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@192.168.3.48:~# /etc/init.d/rsyslog restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/22.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;docker服务器配置syslog驱动&quot;&gt;Docker服务器配置syslog驱动&lt;/h3&gt;

&lt;p&gt;为docker daemon配置syslog驱动，并设置远程syslog日志服务器地址和端口接收日志&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@192.168.3.45:~# dockerd start --log-driver=syslog \
--log-opt syslog-address=tcp://192.168.3.48:514 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;或者启动容器时配置syslog中心服务器记录日志（不建议使用该方式）&lt;/p&gt;
  &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@192.168.3.45:~# docker run --log-driver=syslog \
--log-opt syslog-address=tcp://192.168.3.48:514
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;p&gt;启动nginx容器，访问nginx容器&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@192.168.3.45:~# docker run -it --rm -p 80:80 nginx
root@192.168.3.45:~# curl 192.168.3.45
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/19.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;查看容器，输出了nginx访问日志&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/20.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;查看&lt;strong&gt;syslog服务器&lt;/strong&gt;日志，确定接收到&lt;strong&gt;nginx容器&lt;/strong&gt;日志&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@192.168.3.48:~# cat /var/log/syslog
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/21.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;logstash配置容器方式&quot;&gt;logstash配置（容器方式）&lt;/h3&gt;

&lt;p&gt;logstash容器运行在syslog服务器上，下载logstash镜像，创建logstash配置文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@192.168.3.48:~# docker pull logstash
root@192.168.3.48:~# cd ~ 
root@192.168.3.48:~# mkdir logstash_pipeline
root@192.168.3.48:~# vi logstash_pipeline/logstash.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;定义&lt;code class=&quot;highlighter-rouge&quot;&gt;logstash&lt;/code&gt;输入输出与过滤条件，输入从&lt;strong&gt;tcp10514&lt;/strong&gt;端口接受日志数据（也可以直接读取syslog采集，但需要对syslog文件有读权限），直接输出到标准输出，&lt;a href=&quot;https://www.elastic.co/guide/en/logstash/current/config-examples.html&quot;&gt;更多配置参考&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;input {
  tcp {
    port =&amp;gt; 10514
    codec =&amp;gt; &quot;json&quot;
    type =&amp;gt; &quot;rsyslog&quot;
  }
#    file { 
#       path =&amp;gt; &quot;/logs/syslog&quot; 
#       start_position =&amp;gt; &quot;beginning&quot;
#    }
# stdin { }
}

filter { }

output {
    stdout { }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;启动&lt;strong&gt;logstash&lt;/strong&gt;容器，接收&lt;strong&gt;syslog&lt;/strong&gt;日志&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@192.168.3.48:~# docker run -it --rm -p 192.168.3.48:10514:10514 -v ~/logstash_pipeline/:/logstash_pipeline logstash -f /logstash_pipeline/logstash.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;查看&lt;strong&gt;logstash&lt;/strong&gt;容器输出，成功接收到&lt;strong&gt;syslog&lt;/strong&gt;日志。数据流向&lt;code class=&quot;highlighter-rouge&quot;&gt;nginx容器--&amp;gt;syslog服务器--&amp;gt;logstash容器&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/23.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Kubernetes容器化部署</title>
   <link href="https://robinle.github.io/k8s/2016/12/29/Kubernetes%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
   <updated>2016-12-29T00:00:00+08:00</updated>
   <id>https://robinle.github.io/k8s/2016/12/29/Kubernetes容器化部署</id>
   <content type="html">&lt;p&gt;本文介绍如何部署Kubernetes，由于基础设施环境多样，本文部署情况仅仅针对&lt;strong&gt;裸机或虚拟机&lt;/strong&gt;环境，暂不支持公有云如GCE，AWS，DigitOcean环境，也不支持直接与虚拟化系统如ESXi进行部署。&lt;/p&gt;

&lt;h3 id=&quot;部署方式&quot;&gt;部署方式&lt;/h3&gt;

&lt;p&gt;Kubernetes部署方式分为两种，二进制方式或容器化方式&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;二进制：直接部署所有组件到主机&lt;/li&gt;
  &lt;li&gt;容器化：所有组件在容器内方式运行&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;容器部署kubernetes&quot;&gt;容器部署Kubernetes&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;一、依赖&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;docker-engine 1.12&lt;/li&gt;
  &lt;li&gt;ubuntu16.04&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;二、下载安装包&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下载&lt;a href=&quot;\\192.168.3.36\lan_share_robin\k8s_install_images.tar.gz&quot;&gt;k8s_install_images&lt;/a&gt;到&lt;strong&gt;master&lt;/strong&gt;和&lt;strong&gt;slave&lt;/strong&gt;机器，解压安装包，赋予&lt;code class=&quot;highlighter-rouge&quot;&gt;setup.sh&lt;/code&gt;可执行权限&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/1.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@k8s-master:/home/ubuntu# tar xzf k8s_install_images.tar.gz 
root@k8s-master:/home/ubuntu# ls
k8s_install_images  k8s_install_images.tar.gz
root@k8s-master:/home/ubuntu# cd k8s_install_images
root@k8s-master:/home/ubuntu/k8s_install_images# ls
16.04-xenial  flannel.yaml  images  setup.sh
root@k8s-master:/home/ubuntu/k8s_install_images# chmod +x setup.sh 
root@k8s-master:/home/ubuntu/k8s_install_images# 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/2.PNG&quot; alt=&quot;file:///2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;./setup.sh&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;setup.sh&lt;/code&gt;会自动安装&lt;strong&gt;kubectl&lt;/strong&gt;，&lt;strong&gt;kubernetes-cni&lt;/strong&gt;，&lt;strong&gt;kubelet&lt;/strong&gt;，&lt;strong&gt;kubeadm&lt;/strong&gt;组件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/3.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;并且会自动导入&lt;strong&gt;docker&lt;/strong&gt;镜像&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/4.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;docker images&lt;/code&gt;查看&lt;strong&gt;master&lt;/strong&gt;机器k8s组件镜像信息&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/5.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;strong&gt;kubeadm&lt;/strong&gt;初始化&lt;strong&gt;master&lt;/strong&gt;节点，需要定义pod私有地址范围（不要和主机私有地址范围冲突）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@k8s-master:/home/ubuntu/# kubeadm init --pod-network-cidr=10.244.0.0/16
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/6.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重要：记录&lt;code class=&quot;highlighter-rouge&quot;&gt;kubeadm join --token=&lt;/code&gt;信息，因为slave需要该条指令加入集群&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;创建&lt;strong&gt;flannel&lt;/strong&gt;网络容器&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@k8s-master:/home/ubuntu/k8s_install_images# kubectl apply -f flannel.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/7.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;strong&gt;kubectl&lt;/strong&gt;查看kubernetes组件运行情况&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl get pods --all-namespaces
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/8.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;向&lt;strong&gt;kubernetes&lt;/strong&gt;集群添加&lt;strong&gt;slave&lt;/strong&gt;节点&lt;/p&gt;

&lt;p&gt;下载k8s_install_images安装包，解压，执行&lt;code class=&quot;highlighter-rouge&quot;&gt;setup.sh&lt;/code&gt;同上，安装完&lt;strong&gt;kubeadm&lt;/strong&gt;，&lt;strong&gt;kubectl&lt;/strong&gt;，&lt;strong&gt;kubelet&lt;/strong&gt;等组件后执行&lt;strong&gt;master&lt;/strong&gt;节点初始化后输出的&lt;code class=&quot;highlighter-rouge&quot;&gt;kubeadm join&lt;/code&gt;指令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubeadm join --token=5ac10b.060d697903aae36d 192.168.3.48
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/9.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;master&lt;/strong&gt;节点查看集群情况&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/10.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Kubernetes二进制部署</title>
   <link href="https://robinle.github.io/k8s/2016/12/29/Kubernetes%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2/"/>
   <updated>2016-12-29T00:00:00+08:00</updated>
   <id>https://robinle.github.io/k8s/2016/12/29/Kubernetes二进制部署</id>
   <content type="html">&lt;p&gt;本文介绍如何部署Kubernetes，由于基础设施环境多样，本文部署情况仅仅针对&lt;strong&gt;裸机或虚拟机&lt;/strong&gt;环境，暂不支持公有云如GCE，AWS，DigitOcean环境，也不支持直接与虚拟化系统如ESXi进行部署。&lt;/p&gt;

&lt;h3 id=&quot;部署方式&quot;&gt;部署方式&lt;/h3&gt;

&lt;p&gt;Kubernetes部署方式分为两种，二进制方式或容器化方式&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;二进制：直接部署所有组件到主机&lt;/li&gt;
  &lt;li&gt;容器化：所有组件在容器内方式运行&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;二进制部署kubernetes&quot;&gt;二进制部署Kubernetes&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;一、依赖&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;docker-engine 1.12&lt;/li&gt;
  &lt;li&gt;ubuntu14.04&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;二、下载安装包&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下载&lt;a href=&quot;\\192.168.3.36\lan_share_robin\k8s_install_binaries.tar.gz&quot;&gt;k8s_install_binaries&lt;/a&gt;到&lt;strong&gt;master&lt;/strong&gt;机器，解压安装包&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/11.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进入&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;目录，编辑&lt;code class=&quot;highlighter-rouge&quot;&gt;setup.sh&lt;/code&gt;脚本文件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/12.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/13.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要根据具体部署的集群信息更新&lt;code class=&quot;highlighter-rouge&quot;&gt;setup.sh&lt;/code&gt;脚本文件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;nodes&lt;/strong&gt;：所有节点信息&lt;code class=&quot;highlighter-rouge&quot;&gt;username@ip&lt;/code&gt;，以空格分开，第一个默认为&lt;strong&gt;master&lt;/strong&gt;节点&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;roles&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;a代表master&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;i代表node&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;ai代表master node&lt;/code&gt;，定义&lt;strong&gt;nodes&lt;/strong&gt;参数所有节点的角色信息&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;NUM_NODES&lt;/strong&gt;：节点数量，集群共有多少节点&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SERVICE_CLUSTER_IP_RANGE&lt;/strong&gt;：定义&lt;code class=&quot;highlighter-rouge&quot;&gt;service IP&lt;/code&gt;范围，给定一个&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;私有IP&lt;/code&gt;&lt;/strong&gt;范围，确保不要和&lt;code class=&quot;highlighter-rouge&quot;&gt;本地私有IP &lt;/code&gt;&lt;strong&gt;冲突&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;FLANNEL_NET&lt;/strong&gt;：定义&lt;code class=&quot;highlighter-rouge&quot;&gt;flannel overlay&lt;/code&gt;网络地址，确保不要与&lt;strong&gt;SERVICE_CLUSTER_IP_RANGE&lt;/strong&gt;冲突。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;赋予&lt;code class=&quot;highlighter-rouge&quot;&gt;setup.sh&lt;/code&gt;执行权限，并执行&lt;code class=&quot;highlighter-rouge&quot;&gt;setup.sh&lt;/code&gt;脚本&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重要：如果机器没有&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh&lt;/code&gt;秘钥，则生成秘钥文件，可以不输入直接回车自动生成&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/14.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;安装过程中，需要输入多次&lt;strong&gt;master&lt;/strong&gt;节点和&lt;strong&gt;node&lt;/strong&gt;节点的密码信息，执行结束会得到如下提示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/15.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;master&lt;/strong&gt;节点查看节点信息，验证集群状态&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@k8s-master:/home/ubuntu/k8s_install_binaries/cluster# kubectl get nodes
NAME           STATUS    AGE
192.168.3.44   Ready     5m
192.168.3.48   Ready     4m
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/16.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@k8s-master:/home/ubuntu/k8s_install_binaries/cluster# ps -ef
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/RobinLe/RobinLe.github.io/master/_posts/images/17.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 

</feed>
